/*
 * generated by Xtext 2.13.0
 */
package fr.lip6.veca.ide.validation

import org.eclipse.xtext.validation.Check
import fr.lip6.veca.ide.vecaDsl.VecaDslPackage
import fr.lip6.veca.ide.vecaDsl.Component
import fr.lip6.veca.ide.vecaDsl.IJoinPoint
import fr.lip6.veca.ide.vecaDsl.JoinPoint
import java.util.Arrays
import fr.lip6.veca.ide.vecaDsl.Binding
import fr.lip6.veca.ide.vecaDsl.EJoinPoint
import fr.lip6.veca.ide.vecaDsl.Operation
import fr.lip6.veca.ide.vecaDsl.Message
import fr.lip6.veca.ide.vecaDsl.CompositeComponent
import fr.lip6.veca.ide.vecaDsl.InternalBinding
import fr.lip6.veca.ide.vecaDsl.ExternalBinding
import fr.lip6.veca.ide.vecaDsl.NamedComponent

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class VecaDslValidator extends AbstractVecaDslValidator {
	
public static val INVALID_NAME = 'invalidName'
public static val UNKNOWN_OPERATION = "unknownOperation"
public static val INCOMPATIBLE_OPERATIONS = "incompatibleOperations"
public static val SELF_COMPONENT = "selfComponent"
public static val SELF_BINDING = "selfBinding"
public static val ERROR = "error"

	// component type names begin with a capital
	@Check
	def checkComponentStartsWithCapital(Component c) {
		if (!Character.isUpperCase(c.name.charAt(0))) {
			warning('Component type name should start with a capital', 
					VecaDslPackage.Literals.COMPONENT__NAME,
					INVALID_NAME,
					c.name)
		}
	}
	
	// bindings relate compatible operations
	// two operations are compatible if:
	// - they have the same name
	// - they have the same message types
	// - for external bindings connect prov/prov or req/req (in Component using checkCompatibleOperationsInComponentBindings)
	// - for internal bindings connect prov/req or req/prov (in Component using checkCompatibleOperationsInComponentBindings)
 	@Check
	def checkCompatibleOperationsInBinding(Binding b) {
		val o1 = b.point1.findOperation()
		val o2 = b.point2.findOperation()
		if (o1 !== null && o2 !== null) {
			if (!compatible(o1,o2)) {
				error("Incompatible operations (names and/or messages)",
					VecaDslPackage.Literals.BINDING__POINT1,
					INCOMPATIBLE_OPERATIONS
				)
			}
		}
	}
	
	@Check
	def checkCompatibleOperationsInComponentBindings(CompositeComponent c) {
		for(Binding b: c.bindings) {
			/*
			if (b instanceof InternalBinding) {
				if (!checkCompatibleOperationsInComponentInternalBinding(c, b as InternalBinding)) {
					error("Incompatible operations (should be provided/required or required/provided)",
						VecaDslPackage.Literals.BINDING__POINT1,
						INCOMPATIBLE_OPERATIONS
					)				
				}
			}	
			else if (b instanceof ExternalBinding) {
				if (!checkCompatibleOperationsInComponentExternalBinding(c, b as ExternalBinding)) {
					error("Incompatible operations (should be provided/provided or required/required)",
						VecaDslPackage.Literals.BINDING__POINT1,
						INCOMPATIBLE_OPERATIONS
					)						
				}
			}
			* 
			*/	
		}
	}
	
	// no self binding
	@Check
	def checkNoSelfBinding(InternalBinding b) {
		val p1 = b.point1 as IJoinPoint
		val p2 = b.point2 as IJoinPoint
		if (p1.component.name.equals(p2.component.name)) {
			error("Self-binding is not allowed",
				VecaDslPackage.Literals.BINDING__POINT1,
				SELF_BINDING
			)
		}
	}

	// operations used in internal bindings do exist 
 	@Check
	def checkExistingOperationInBinding(Binding b) {
		val p1 = b.point1
		val p2 = b.point2
		for(JoinPoint p : Arrays.asList(p1,p2)) {
			if (p instanceof IJoinPoint) {
				if (!p.checkJoinPoint()) {
					error('''Unknown operation «p.component.name».«p.operation»''', 
						getCause(p,p1,p2),
						UNKNOWN_OPERATION
					)
				}
			}
		}
	}
	
	// no component named self
	@Check
	def checkNoComponentNamedSelf(NamedComponent n) {
		if(n.name.equals("self")) {
			error("A component instance should not be named 'self'",
				VecaDslPackage.Literals.NAMED_COMPONENT__NAME,
				SELF_COMPONENT
			)
		}
	}
	
	// helpers
	
	def equals(Message m1, Message m2) {
		if (m1===null || m2===null)
			return m1===m2
		return m1.name.equals(m2.name)
	}
	
	def compatible(Operation o1, Operation o2) {
		return
			o1.name.equals(o2.name) &&
			equals(o1.inputMessage, o2.inputMessage) &&
			equals(o1.outputMessage, o2.outputMessage)
	}

	def findOperation(JoinPoint p) {	
		if (p instanceof EJoinPoint) {
			return p.operation
		}
		else {
			// can be null
			return (p as IJoinPoint).component.type.findOperation((p as IJoinPoint).operation)
		}	
	}
		
	def getCause(JoinPoint p, JoinPoint p1, JoinPoint p2) {
		if (p===p1)
			return VecaDslPackage.Literals.BINDING__POINT1
		else
			return VecaDslPackage.Literals.BINDING__POINT2
	}
	
	def checkJoinPoint(IJoinPoint p) {
		// p is x.o, we have to check there is an operation o in x
		return p.component.type.hasOperation(p.operation)
	}
	
	def hasOperation(Component c, String oname) {
		return isProvidedOperation(c,oname) || isRequiredOperation(c,oname)
	}
	
	def findOperation(Component c, String oname) {
		var o = c.signature.providedOps?.findFirst[it.name.equals(oname)]
		if (o === null) {
			o = c.signature.requiredOps?.findFirst[it.name.equals(oname)]
		}
		return o
	}
	
	def isProvidedOperation(Component c, String oname) {
		if(c.signature.providedOps !== null)
			return c.signature.providedOps.exists[it.name.equals(oname)]
		return false
	}
	
	def isRequiredOperation(Component c, String oname) {
		if(c.signature.requiredOps !== null)
			return c.signature.requiredOps.exists[it.name.equals(oname)]
		return false
	}
	
	// an internal binding c1.o1 - c2.o2 is ok if
	// - either o1 is provided by c1 and o2 is required by c2
	// - or o1 is required by c1 and o2 is provided by c2
	// note that for full correctness, we also have to use checkCompatibleOperationsInBinding (checks op names and messages)
	def checkCompatibleOperationsInComponentInternalBinding(CompositeComponent c, InternalBinding b) {
		val o1 = (b.point1 as IJoinPoint).operation
		val o2 = (b.point2 as IJoinPoint).operation
		val c1 = (b.point1 as IJoinPoint).component.type
		val c2 = (b.point2 as IJoinPoint).component.type
		return (isProvidedOperation(c1,o1) && isRequiredOperation(c2,o2)) || (isRequiredOperation(c1,o1) && isProvidedOperation(c2,o2))			
	}

	// an external binding c1.o1 - c2.o2 is ok if
	// - either o1 is provided by c1 and o2 is provided by c2
	// - or o1 is required by c1 and o2 is required by c2
	// note that for full correctness, we also have to use checkCompatibleOperationsInBinding (checks op names and messages)
	def checkCompatibleOperationsInComponentExternalBinding(CompositeComponent c, ExternalBinding b) {
		if (b.point1 instanceof EJoinPoint && b.point2 instanceof IJoinPoint) {
			val o1 = (b.point1 as EJoinPoint).operation.name
			val o2 = (b.point2 as IJoinPoint).operation
			val c1 = c
			val c2 = (b.point2 as IJoinPoint).component.type
			return (isProvidedOperation(c1,o1) && isProvidedOperation(c2,o2)) || (isRequiredOperation(c1,o1) && isRequiredOperation(c2,o2))	
		}		
		else if (b.point1 instanceof IJoinPoint && b.point2 instanceof EJoinPoint) {
			val o1 = (b.point1 as IJoinPoint).operation
			val o2 = (b.point2 as EJoinPoint).operation.name
			val c1 = (b.point1 as IJoinPoint).component.type
			val c2 = c
			return (isProvidedOperation(c1,o1) && isProvidedOperation(c2,o2)) || (isRequiredOperation(c1,o1) && isRequiredOperation(c2,o2))	
		}
		else // not possible wrt the grammar
			return false
	}
	
}
