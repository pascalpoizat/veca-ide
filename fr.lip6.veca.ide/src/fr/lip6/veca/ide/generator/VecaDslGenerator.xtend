/*
 * generated by Xtext 2.13.0
 */
package fr.lip6.veca.ide.generator

import fr.lip6.veca.ide.vecaDsl.Action
import fr.lip6.veca.ide.vecaDsl.BasicComponent
import fr.lip6.veca.ide.vecaDsl.Behavior
import fr.lip6.veca.ide.vecaDsl.Binding
import fr.lip6.veca.ide.vecaDsl.CommunicationAction
import fr.lip6.veca.ide.vecaDsl.CommunicationKind
import fr.lip6.veca.ide.vecaDsl.Component
import fr.lip6.veca.ide.vecaDsl.CompositeComponent
import fr.lip6.veca.ide.vecaDsl.EJoinPoint
import fr.lip6.veca.ide.vecaDsl.ExternalBinding
import fr.lip6.veca.ide.vecaDsl.IJoinPoint
import fr.lip6.veca.ide.vecaDsl.InternalAction
import fr.lip6.veca.ide.vecaDsl.InternalBinding
import fr.lip6.veca.ide.vecaDsl.JoinPoint
import fr.lip6.veca.ide.vecaDsl.Message
import fr.lip6.veca.ide.vecaDsl.Model
import fr.lip6.veca.ide.vecaDsl.NamedComponent
import fr.lip6.veca.ide.vecaDsl.Operation
import fr.lip6.veca.ide.vecaDsl.Signature
import fr.lip6.veca.ide.vecaDsl.State
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.io.IOException
import org.eclipse.core.runtime.Path
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.ResourcesPlugin
import java.net.URI
import java.io.File
import org.eclipse.core.runtime.IPath
import java.util.Arrays

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class VecaDslGenerator extends AbstractGenerator {
	
	public static final String JSON_FILE_EXTENSION = "json"
	public static final String XTA_FILE_EXTENSION = "xta"
	public static final String LOG_FILE_EXTENSION = "log"
	
	public static final String OSX_COMMAND = "%s/veca-haskell-exe"
	public static final String VECA_COMMAND = "transform"
	public static final String DEFAULT_OSX_VECA_HOME = "%s/.local/bin"
	
	public static final String DEFAULT_GENERATION_FOLDER = "src-gen"

	static final Logger log = new Logger
		
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		log.reset
		// setup
		val model = resource.allContents.filter(Model).toList.get(0)
		val vecaURI = resource.URI
		val vecaTrimmedURI = vecaURI.trimFileExtension
		val vecaFileName = vecaURI.lastSegment
		val jsonFileName = vecaTrimmedURI
			.appendFileExtension(JSON_FILE_EXTENSION)
			.lastSegment
		val xtaFileName = vecaTrimmedURI
			.appendFileExtension(XTA_FILE_EXTENSION)
			.lastSegment
		val logFileName = vecaTrimmedURI
			.appendFileExtension(LOG_FILE_EXTENSION)
			.lastSegment
		// generate JSON file
		// doGenerateJSON(fsa, model, vecaFileName, jsonFileName, log)
		/*
		// generate XTA file
		if (vecaURI.isPlatformResource()) {
			val path = new Path(vecaTrimmedURI.toPlatformString(true))
			val IFile file = ResourcesPlugin.getWorkspace.getRoot.getFile(path)
			val rawIPath = file.getLocation
			val rawPath = rawIPath.removeLastSegments(1)
			val fileName = String.format("%s%s%s%s%s",
				rawPath.toOSString,
				File.separator,
				DEFAULT_GENERATION_FOLDER,
				File.separator,
				vecaTrimmedURI.lastSegment
			)
			doGenerateXTA(fsa, jsonFileName, xtaFileName, fileName, log)
		} else {
			log.error(String.format("cannot work with resource %s (error wrt Eclipse resource / path).", vecaURI), true)
			log.error("only the JSON file has been generated, please perform the transformation in XTA manually.", true)
		}*/
		fsa.generateFile(logFileName, log.toString)
	}
	
	def void doGenerateJSON(IFileSystemAccess2 fsa, Model model, String vecaFileName, String jsonFileName, Logger log) {
		log.info(String.format("VECA to JSON transformation %s -> %s.", vecaFileName, jsonFileName), true)
		fsa.generateFile(jsonFileName, model.doGenerate)
		log.info("done.", true)
	}
	
	def void doGenerateXTA(IFileSystemAccess2 fsa, String jsonFileName, String xtaFileName, String path, Logger log) {
		log.info(String.format("JSON to XTA transformation %s -> %s.", jsonFileName, xtaFileName), true)
		val osname = System.getProperty("os.name").toUpperCase
		log.info(String.format("detected OS is %s.", osname), true)
		// for OSX and Linux
		if (Helper.underOSX(osname) || Helper.underLinux(osname)) {
			var home = System.getenv("HOME")
			var vecaHome = System.getenv("VECA_HOME")
			if (vecaHome === null) {
				vecaHome = String.format(DEFAULT_OSX_VECA_HOME, home)			
				log.info(String.format("VECA_HOME is not set, setting it to %s.", vecaHome), true)
			} else {
				log.info(String.format("VECA_HOME set to %s.", vecaHome), true)
			}
			Helper.execute(Arrays.asList(String.format(OSX_COMMAND, vecaHome), VECA_COMMAND, path), log)
		// else (Windows, ...) not yet supported
		} else {
			log.error("unsupported OS.", true)
		}
	}
		
	def doGenerate(Model m) '''
	«doGenerate(m.root)»
	'''

	def doGenerate(Component c) {
		if(c instanceof BasicComponent)
			doGenerate(c as BasicComponent)
		else if(c instanceof CompositeComponent) {
			doGenerate(c as CompositeComponent)
		}
		else ''''''
	}
	
	def doGenerate(BasicComponent c) '''
	{
		"componentId": ["«c.name»"],
		"tag": "BasicComponent",
		"signature": «doGenerate(c.signature)»,
		"behavior": «doGenerate(c.behavior)»
	}
	'''
	
	def doGenerate(CompositeComponent c) {
		var inbinds = c.bindings.filter[it.binfo instanceof InternalBinding]
		var extbinds = c.bindings.filter[it.binfo instanceof ExternalBinding]
	'''
	{
		"componentId": ["«c.name»"],
		"tag": "CompositeComponent",
		"signature": «doGenerate(c.signature)»,
		"children": [
			«c.children.map[doGenerate].join(",")»
		],
		"inbinds": [
			«inbinds.map[doGenerate].join(",")»
		],
		"extbinds": [
			«extbinds.map[doGenerate].join(",")»
		]
	}
	'''
	}
	
	def doGenerate(Signature s) {
		var ops = s.providedOps
		ops.addAll(s.requiredOps)
	'''
	{
		"providedOperations": [«s.providedOps.map[doGenerate].join(",")»],
		"requiredOperations": [«s.requiredOps.map[doGenerate].join(",")»],
		"input": [
			«ops.map[doGenerateInput].join(",")»
		],
		"output": [
			«ops.map[doGenerateOutput].join(",")»
		]
	}
	'''
	}
	
	def doGenerate(Operation o) '''["«o.name»"]'''
	
	def doGenerateInput(Operation o) '''
	[
		«doGenerate(o)»,
		«doGenerate(o.inputMessage)»
	]
	'''
	
	def doGenerateOutput(Operation o) '''
	[
		«doGenerate(o)»,
		«IF o.outputMessage === null»
		null
		«ELSE»
		«doGenerate(o.outputMessage)»
		«ENDIF»
	]
	'''
	
	def doGenerate(Message m) '''
	{
		"messagename": ["«m.name»"],
		"messagetype": ""
	}
	'''
	
	def doGenerate(NamedComponent n) '''
	{
		"instanceId": ["«n.name»"],
		"componentType": «doGenerate(n.type)»
	}
	'''
	
	def doGenerate(Behavior b) {
		val alphabet = BehaviorGenerator.instance.computeAlphabet(b)
		val states = BehaviorGenerator.instance.computeStates(b)
		val transitions = BehaviorGenerator.instance.computeTransitions(b)
	'''
	{
		"mid": [],
		"alphabet": [«alphabet.map[doGenerate].join(",")»],
		"states": [«states.map[doGenerate].join(",")»],
		"initialState": «doGenerate(b.initialState)»,
		"finalStates": [«b.finalStates.map[doGenerate].join(",")»],
		"transitions": [«transitions.map[doGenerate].join(",")»]
	}
	'''	
	}
	
	def doGenerate(GenState s) '''"«s.state.name»"'''
	
	def doGenerate(State s) '''"«s.name»"'''
	
	def doGenerate(GenTransition t) '''
	{
		"source": «doGenerate(t.source)»,
		"target": «doGenerate(t.target)»,
		"label": «doGenerate(t.label)»
	}
	'''
	
	def doGenerate(Action a) {
		if(a instanceof CommunicationAction) {
			return doGenerate(a as CommunicationAction)	
		}
		else if (a instanceof InternalAction) {
			return doGenerate(a as InternalAction)
		}
		else {
			return ""
		}
	}
	
	def doGenerate(GenAction a) {
		return doGenerate(a.action);
	}
		
	def doGenerate(InternalAction a) '''
	{
		"tag": "CTau"
	}
	'''
	
	def doGenerate(CommunicationAction e) '''
	{
		"tag": "«doGenerate(e.communicationKind)»",
		"contents": «doGenerate(e.operation)»
	}
	'''
	
	def doGenerate(CommunicationKind k) {
		switch k {
			case RECEIVE: "CReceive"
			case REPLY: "CReply"
			case INVOKE: "CInvoke"
			case RESULT: "CResult"
			default: ""
		}
	}
	
	def doGenerate(Binding b) '''
	{
		"bindingType": «IF b.binfo instanceof InternalBinding»"Internal"«ELSE»"External"«ENDIF»,
		"bindingId": ["«b.name»"],
		"from": «doGenerate(b.binfo.point1)»,
		"to": «doGenerate(b.binfo.point2)»
	}
	'''
	
	def doGenerate(JoinPoint p) {
		if (p instanceof EJoinPoint)
			doGenerate(p as EJoinPoint)
		else
			doGenerate(p as IJoinPoint)
	}
	
	def doGenerate(EJoinPoint p) '''
	{
		"jpname": [],
		"jpoperation": «doGenerate(p.operation)»
	}	'''
	
	def doGenerate(IJoinPoint p) '''
	{
		"jpname": ["«p.component.name»"],
		"jpoperation": ["«p.operation»"]
	}
	'''
		
}
